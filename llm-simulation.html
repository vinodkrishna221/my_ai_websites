<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Adventure: How Computers Talk!</title>
    <style>
        :root {
            --primary-color: #3498db; /* Blue */
            --secondary-color: #2ecc71; /* Green */
            --accent-color: #f39c12; /* Orange */
            --highlight-color: #e74c3c; /* Red for emphasis */
            --text-color: #333;
            --bg-color: #f4f7f6;
            --container-bg: #ffffff;
            --panel-bg: #e0f7fa; /* Light cyan */
            --border-color: #b0bec5; /* Softer grey */
            --animation-speed-factor: 1;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Arial Rounded MT Bold', sans-serif; /* Child-friendly font */
            line-height: 1.6;
            margin: 0;
            padding: 15px;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--container-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 25px rgba(0,0,0,0.12);
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px dashed var(--primary-color);
            padding-bottom: 15px;
        }

        header h1 {
            color: #2c3e50; /* Darker blue-grey */
            margin-bottom: 5px;
            font-size: 2em;
        }

        header p {
            font-size: 1.1em;
            color: #555;
        }

        .status-panel {
            background-color: var(--panel-bg);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1em;
            min-height: 2em;
            transition: background-color 0.3s ease, transform 0.2s ease;
            border: 2px solid var(--primary-color);
        }
        .status-panel.active-step {
            background-color: #cceeff; /* Lighter blue for active */
            transform: scale(1.02);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .controls button, .controls label {
            padding: 12px 18px;
            border: none;
            border-radius: 20px; /* Rounded buttons */
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .controls button:hover:not(:disabled) {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        .controls button:disabled {
            background-color: #95a5a6; /* Greyed out */
            cursor: not-allowed;
        }
        .controls input[type="range"] {
            margin-left: 8px;
            vertical-align: middle;
            cursor: pointer;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
            margin-top: 20px;
        }
        
        @media (min-width: 1024px) {
            .simulation-area {
                grid-template-columns: repeat(3, 1fr);
            }
        }


        .stage {
            border: 2px solid var(--border-color);
            padding: 20px;
            border-radius: 10px;
            background-color: #fdfdfd;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }

        .stage h2 {
            margin-top: 0;
            font-size: 1.4em;
            color: #34495e;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
            position: relative;
        }
        .stage h3 {
            font-size: 1.15em;
            color: #546e7a;
            margin-top: 18px;
            margin-bottom: 10px;
        }
        .stage h2 .tooltip-trigger, .stage h3 .tooltip-trigger {
            display: inline-block;
            width: 22px;
            height: 22px;
            background-color: var(--accent-color); /* Orange for question mark */
            color: white;
            border-radius: 50%;
            text-align: center;
            font-size: 16px;
            line-height: 22px;
            cursor: help;
            margin-left: 8px;
            font-style: normal;
            user-select: none;
            font-weight: bold;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: left;
            font-weight: normal;
            font-size: 0.95em;
            line-height: 1.5;
            border-radius: 6px;
            padding: 10px 15px;
            position: absolute;
            z-index: 100;
            bottom: 140%;
            left: 50%;
            margin-left: -125px; /* Half of width */
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 3px 8px rgba(0,0,0,0.25);
        }
        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -7px;
            border-width: 7px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .tooltip:hover .tooltip-text, .tooltip .tooltip-trigger:focus + .tooltip-text {
            visibility: visible;
            opacity: 1;
        }


        #input-text {
            width: calc(100% - 24px);
            min-height: 70px;
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            font-size: 1.1em;
            margin-bottom: 10px;
            resize: vertical;
        }

        .tokens-display, .embeddings-display, .contextualized-embeddings-display, .output-assembly-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 8px;
            padding: 12px;
            border: 2px dashed var(--primary-color);
            min-height: 60px;
            background-color: #e9f5fe; /* Light blue tint */
            position: relative;
            border-radius: 6px;
        }

        .token, .embedding-bar, .output-token {
            padding: 8px 12px;
            border: 2px solid var(--primary-color);
            background-color: #d6eaff; /* Brighter token bg */
            border-radius: 5px;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease-in-out, background-color 0.1s, border-color 0.1s, transform 0.2s ease;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }
        .token .token-id {
            font-size: 0.7em;
            color: #333;
            display: block;
            margin-top: 3px;
            font-weight: normal;
        }

        .embedding-bar {
            display: flex;
            width: 70px; 
            height: 30px;
            padding: 0;
            border: 2px solid var(--secondary-color); /* Green border */
            background-color: transparent;
            position: relative; /* For positional icon */
        }
        .embedding-segment {
            flex-grow: 1;
            height: 100%;
            transition: background-color 0.3s ease-in-out;
        }
        .embedding-bar .vector-label {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #555;
            white-space: nowrap;
            background-color: rgba(255,255,255,0.8);
            padding: 1px 3px;
            border-radius: 2px;
        }
        .embedding-bar .positional-icon {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: gold;
            color: #333;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            line-height: 18px;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 0 5px gold;
            opacity: 0;
            transform: scale(0.5);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .embedding-bar.positional-encoded .positional-icon {
            opacity: 1;
            transform: scale(1);
        }
        .embedding-bar.is-processing {
            border-width: 3px;
            border-color: var(--accent-color);
            transform: scale(1.15);
            box-shadow: 0 0 10px var(--accent-color);
        }
        .embedding-bar.contextualized {
            border-color: #9b59b6; /* Purple for contextualized */
            animation: glow-contextualized 1s ease-in-out;
        }
        @keyframes glow-contextualized {
            0% { box-shadow: 0 0 0px #9b59b6; }
            50% { box-shadow: 0 0 12px #9b59b6; }
            100% { box-shadow: 0 0 0px #9b59b6; }
        }

        .transformer-layer-visualization {
            border: 2px solid #8e44ad; /* Darker Purple */
            padding: 20px;
            margin-top: 15px;
            border-radius: 8px;
            text-align: center;
            background: linear-gradient(45deg, #f3e5f5, #e1bee7);
            min-height: 120px;
            position: relative;
        }
        .transformer-layer-visualization h3 {
            margin-top:0; color: #8e44ad; font-size: 1.15em;
        }
        .attention-line {
            position: absolute;
            background-color: rgba(243, 156, 18, 0.7); /* Brighter orange */
            height: 3px; /* Thicker lines */
            transform-origin: left center;
            z-index: 5;
            transition: all 0.3s ease, opacity 0.2s ease, width 0.2s ease;
            pointer-events: none;
            border-radius: 2px;
        }


        #generation-stage .vocabulary-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px;
            border: 2px dashed #16a085; /* Teal */
            min-height: 35px;
            background-color: #e0f2f1; /* Light teal */
            margin-bottom:12px;
            border-radius: 6px;
        }
        #generation-stage .vocab-token {
            padding: 5px 10px;
            border: 1px solid #16a085;
            background-color: #a7ffeb; /* Brighter vocab token */
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
        }
        #generation-stage .probability-display {
            min-height: 90px;
            display: flex;
            align-items: flex-end;
            gap: 3%;
            padding: 12px;
            border: 2px solid var(--accent-color);
            margin-bottom:12px;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
            background-color: #fff9e6; /* Light orange */
        }
        .prob-bar {
            flex-grow: 1;
            background-color: var(--primary-color);
            text-align: center;
            color: white;
            font-size: 0.8em;
            padding-top: 4px;
            border-radius: 4px 4px 0 0;
            transition: height 0.4s ease-in-out, background-color 0.3s ease-in-out, transform 0.2s ease;
            position: relative;
            overflow: visible; /* Allow text to pop out a bit */
            max-width: 18%;
            font-weight: bold;
        }
        .prob-bar span {
            display: block;
            white-space: nowrap;
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%) rotate(-60deg);
            transform-origin: center;
            padding: 2px 4px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 3px;
        }
        .prob-bar.selected {
            background-color: var(--highlight-color); /* Red for selected */
            transform: scaleY(1.1);
        }

        .output-assembly-area {
            border-color: var(--secondary-color);
            background-color: #e6ffed; /* Light green */
        }
        .output-token {
            border-color: #27ae60; /* Darker green */
            background-color: #c8e6c9; /* Softer green */
        }
        .output-token.eos {
            background-color: var(--highlight-color);
            color: white;
            border-color: #c0392b;
            font-weight: bold;
        }
        .feedback-animation-token {
            position: absolute;
            opacity: 0.9;
            border: 2px dashed var(--accent-color);
            background-color: rgba(243, 156, 18, 0.3);
            z-index: 20;
            pointer-events: none;
            transition: transform 0.8s cubic-bezier(0.5, -0.5, 0.5, 1.5), opacity 0.8s ease-in-out;
            font-weight: bold; /* Make text more visible */
        }


        .fade-in { animation: fadeIn 0.6s ease-in-out forwards; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        .legend {
            margin-top: 30px;
            padding: 20px;
            background-color: #ecf0f1; /* Light grey */
            border-radius: 8px;
            border: 2px solid #bdc3c7;
        }
        .legend h3 { margin-top: 0; text-align: center; color: #2c3e50; font-size: 1.3em; }
        .legend ul { list-style: none; padding: 0; display: flex; flex-wrap: wrap; gap: 25px; justify-content: center; }
        .legend li { font-size: 1em; display: flex; align-items: center; }
        .legend .legend-item-vis {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
            border: 2px solid #7f8c8d;
            border-radius: 4px;
        }
        .legend-token { background-color: #d6eaff; border-color: var(--primary-color); }
        .legend-embedding { background: linear-gradient(to right, #ffdddd, #ddffdd, #ddddff); border-color: var(--secondary-color); }
        .legend-attention { width: 25px; height: 4px; background-color: var(--accent-color); border: none;}
        .legend-positional { background-color: gold; width:12px; height:12px; border-radius:50%; border-color:darkorange;}

        @media (max-width: 1023px) and (min-width: 768px) { /* Tablet: 2 columns */
             .simulation-area { grid-template-columns: 1fr 1fr; }
             #input-stage-col { grid-column: 1 / 2; }
             #understanding-stage-col { grid-column: 1 / 2; }
             #generation-stage-col { grid-column: 2 / 3; }
        }
        @media (max-width: 767px) { /* Mobile: 1 column */
            body { padding: 10px; }
            .container { padding: 15px; }
            .controls { flex-direction: column; }
            .controls button, .controls label { width: 100%; justify-content: center; }
            .stage h2 { font-size: 1.2em; }
            .tooltip .tooltip-text { width: 200px; margin-left: -100px; }
            .prob-bar span { font-size: 0.9em; transform: translateX(-50%) rotate(0); }
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Let's See How Computers Talk!</h1>
            <p>Imagine we're teaching a computer to understand our words and talk back. This shows how it learns, one step at a time, like building with word blocks!</p>
        </header>

        <div class="status-panel" id="status-panel">
            Hello! Type something like "tell a story" or "what is a cat" and press "Start!"
        </div>

        <div class="controls">
            <button id="process-btn">Start!</button>
            <button id="next-step-btn" disabled>Next Block</button>
            <button id="play-pause-btn" disabled>Play All</button>
            <button id="reset-btn" disabled>Again!</button>
            <label for="speed-slider">Speed:
                <input type="range" id="speed-slider" min="0.1" max="2.5" value="1.2" step="0.1" title="Slower <-> Faster">
            </label>
        </div>

        <div class="simulation-area">
            <div id="input-stage-col">
                <section class="stage" id="input-stage">
                    <h2>1. Your Words!
                        <span class="tooltip"><span class="tooltip-trigger" tabindex="0">?</span>
                        <span class="tooltip-text">You type your words here. This is what we want the computer to understand.</span></span>
                    </h2>
                    <textarea id="input-text" placeholder="e.g., tell a story"></textarea>
                    <h3>Word Blocks (Tokens)
                        <span class="tooltip"><span class="tooltip-trigger" tabindex="0">?</span>
                        <span class="tooltip-text">The computer breaks your sentence into small 'word blocks'. Each block is a token. Easy to work with!</span></span>
                    </h3>
                    <div class="tokens-display" id="tokens-display-area"></div>
                </section>
            </div>

            <div id="understanding-stage-col">
                <section class="stage" id="understanding-stage">
                    <h2>2. Computer Thinks...</h2>
                    <h3>Meaning Colors (Embeddings)
                        <span class="tooltip"><span class="tooltip-trigger" tabindex="0">?</span>
                        <span class="tooltip-text">Each word block gets special 'meaning colors'. Similar words get similar colors. It's like a secret code for what words mean!</span></span>
                    </h3>
                    <div class="embeddings-display" id="embeddings-display-area"></div>
                    
                    <h3>Order Numbers (Positional Encoding)
                        <span class="tooltip"><span class="tooltip-trigger" tabindex="0">?</span>
                        <span class="tooltip-text">The computer needs to know the order of words. We add a little 'number tag' to each block so it knows which came first, second, etc.</span></span>
                    </h3>
                    
                    <div class="transformer-layer-visualization" id="transformer-layer-area">
                        <h3>Word Blocks Talk! (Attention)
                            <span class="tooltip"><span class="tooltip-trigger" tabindex="0">?</span>
                            <span class="tooltip-text">Word blocks 'talk' to each other to understand the whole sentence. Important words 'talk' louder (brighter lines)! This helps understand tricky words like 'bat' (animal or sports bat?).</span></span>
                        </h3>
                        <div class="contextualized-embeddings-display" id="contextualized-embeddings-display-area"></div>
                    </div>
                    <p style="text-align:center; font-style:italic; font-size:0.9em; margin-top:10px;">(Smart computers do this 'talking' many times to get super smart!)</p>
                </section>
            </div>

            <div id="generation-stage-col">
                <section class="stage" id="generation-stage">
                    <h2>3. Computer Talks Back!</h2>
                    <h3>Guessing Next Word Block
                        <span class="tooltip"><span class="tooltip-trigger" tabindex="0">?</span>
                        <span class="tooltip-text">Now the computer guesses which word block comes next. It shows its best guesses with taller bars for better guesses!</span></span>
                    </h3>
                    <div class="vocabulary-display" id="vocabulary-display-area">
                        <!-- Simplified vocabulary will be shown here -->
                    </div>
                    <div class="probability-display" id="probability-display-area">
                        <!-- Probability visualization (e.g., bars) will appear here -->
                    </div>
                    <h3>Building the Answer
                        <span class="tooltip"><span class="tooltip-trigger" tabindex="0">?</span>
                        <span class="tooltip-text">The computer picks the best guess and adds it to its answer. Then, it uses *all* the words (yours and its own) to guess the *next* word. It keeps going like this!</span></span>
                    </h3>
                    <div class="output-assembly-area" id="output-assembly-area"></div>
                    <p id="eos-message" style="text-align:center; font-style:italic; font-size:0.9em; margin-top:10px; display:none; color: var(--highlight-color); font-weight:bold;">"All done!" The computer added a special 'Stop' block.</p>
                </section>
            </div>
        </div>

        <div class="legend">
            <h3>What These Pictures Mean:</h3>
            <ul>
                <li><span class="legend-item-vis legend-token"></span> Word Block: One word piece.</li>
                <li><span class="legend-item-vis legend-embedding"></span> Meaning Colors: Shows what a word means.</li>
                <li><span class="legend-item-vis legend-positional"></span> Order Tag: Shows word order.</li>
                <li><span class="legend-item-vis legend-attention"></span> Talking Line: How words connect.</li>
            </ul>
        </div>
    </div>

    <script>
        (function() {
            const LLMSim = {
                config: {
                    baseAnimationSpeed: 500, 
                    // NEW: Predefined stories for better coherence
                    stories: {
                        "default": ["the", "cat", "sat", "EOS"],
                        "tell a story": ["once", "upon", "a", "time", "a", "dragon", "flew", "EOS"],
                        "what is a cat": ["a", "cat", "is", "a", "fluffy", "animal", "EOS"],
                        "hello": ["hello", "there", "how", "are", "you", "EOS"],
                        "colors": ["red", "blue", "green", "yellow", "EOS"]
                    },
                    // Vocab should include words from stories + a few more
                    vocab: ["a", "animal", "are", "blue", "cat", "dragon", "flew", "fluffy", "green", "hello", 
                            "how", "is", "once", "red", "sat", "tell", "the", "there", "time", "upon", "what", 
                            "yellow", "you", "story", "EOS", "happy", "big", "small", "ran"],
                    embeddingSize: 4, // Simplified a bit
                    maxGeneratedTokens: 10, // Increased slightly
                    attentionLayers: 1, 
                    topNProbabilities: 5,
                },
                state: {
                    userInput: '',
                    tokens: [], 
                    embeddings: [], 
                    contextualizedEmbeddings: [], 
                    generatedTokens: [], 
                    currentStorySequence: [], // NEW: To hold the predefined sequence for current input
                    isPlaying: false,
                    isReset: true,
                    currentStepPromise: null,
                    currentStepPromiseInProgress: false,
                    stepQueue: [],
                    simulationSpeedFactor: 1.2, 
                    abortController: null,
                },
                dom: {},

                init: function() {
                    // (DOM element gathering is the same, so omitted for brevity in this comment block)
                    this.dom.statusPanel = document.getElementById('status-panel');
                    this.dom.processBtn = document.getElementById('process-btn');
                    this.dom.nextStepBtn = document.getElementById('next-step-btn');
                    this.dom.playPauseBtn = document.getElementById('play-pause-btn');
                    this.dom.resetBtn = document.getElementById('reset-btn');
                    this.dom.speedSlider = document.getElementById('speed-slider');
                    this.dom.inputTextArea = document.getElementById('input-text');
                    this.dom.tokensDisplayArea = document.getElementById('tokens-display-area');
                    this.dom.embeddingsDisplayArea = document.getElementById('embeddings-display-area');
                    this.dom.transformerLayerArea = document.getElementById('transformer-layer-area');
                    this.dom.contextualizedEmbeddingsDisplayArea = document.getElementById('contextualized-embeddings-display-area');
                    this.dom.vocabularyDisplayArea = document.getElementById('vocabulary-display-area');
                    this.dom.probabilityDisplayArea = document.getElementById('probability-display-area');
                    this.dom.outputAssemblyArea = document.getElementById('output-assembly-area');
                    this.dom.eosMessage = document.getElementById('eos-message');
                    
                    this.dom.inputTextArea.value = "tell a story"; // Default example

                    this.dom.processBtn.addEventListener('click', () => this.handleProcess());
                    this.dom.nextStepBtn.addEventListener('click', () => this.handleNextStep());
                    this.dom.playPauseBtn.addEventListener('click', () => this.handlePlayPause());
                    this.dom.resetBtn.addEventListener('click', () => this.handleReset());
                    
                    this.dom.speedSlider.addEventListener('input', (e) => {
                        this.state.simulationSpeedFactor = parseFloat(e.target.value);
                    });
                    this.state.simulationSpeedFactor = parseFloat(this.dom.speedSlider.value);

                    this.updateStatus("Hello! Type something like 'tell a story' and press 'Start!'");
                    this.updateControls();
                    this.displayVocabulary();
                },
                
                getAnimSpeed: function(multiplier = 1) {
                    return this.config.baseAnimationSpeed * this.state.simulationSpeedFactor * multiplier;
                },

                sleep: function(ms) {
                    if (this.state.abortController && this.state.abortController.signal.aborted) {
                        return Promise.resolve(); 
                    }
                    return new Promise((resolve) => {
                        const timeoutId = setTimeout(resolve, ms);
                        if (this.state.abortController) {
                            this.state.abortController.signal.addEventListener('abort', () => {
                                clearTimeout(timeoutId);
                                resolve(); 
                            });
                        }
                    });
                },

                handleProcess: async function() {
                    if (this.state.abortController) { 
                        this.state.abortController.abort();
                    }
                    this.state.abortController = new AbortController();

                    this.state.isPlaying = true; 
                    this.state.isReset = false;
                    this.dom.inputTextArea.disabled = true;
                    this.updateControls();
                    this.clearVisualizationAreas();

                    this.state.userInput = this.dom.inputTextArea.value.trim().toLowerCase();
                    if (!this.state.userInput) {
                        this.updateStatus("Oops! Please type some words first.");
                        this.state.isPlaying = false;
                        this.dom.inputTextArea.disabled = false;
                        this.updateControls();
                        return;
                    }

                    // NEW: Select story based on input
                    if (this.config.stories[this.state.userInput]) {
                        this.state.currentStorySequence = [...this.config.stories[this.state.userInput]];
                    } else {
                        // Fallback to a default story if input not recognized
                        const randomStoryKey = Object.keys(this.config.stories)[Math.floor(Math.random() * Object.keys(this.config.stories).length)];
                        this.state.currentStorySequence = [...this.config.stories[randomStoryKey]];
                        this.updateStatus(`Hmm, I don't have a special story for that. Let's try this one: "${randomStoryKey}"`);
                        await this.sleep(this.getAnimSpeed(3)); // Pause to read message
                    }


                    this.state.stepQueue = [
                        this.tokenizeInput,
                        this.createEmbeddings,
                        this.applyPositionalEncoding,
                        this.runAttentionMechanism,
                        this.prepareForGeneration,
                    ];
                    
                    this.state.currentStepPromise = this.executeNextStepChain();
                },

                handleNextStep: async function() {
                    this.state.isPlaying = false; 
                    this.updateControls();
                    if (this.state.currentStepPromiseInProgress) {
                         try { await this.state.currentStepPromise; } catch (e) { /* ignore abort */ }
                    }
                    if (this.state.stepQueue.length > 0 && !this.state.currentStepPromiseInProgress) {
                        this.state.currentStepPromise = this.executeNextStepChain(true); 
                    } else if (this.state.stepQueue.length === 0 && !this.state.isReset) {
                        this.updateStatus("All done with this adventure! Try 'Again!'");
                    }
                },

                handlePlayPause: function() {
                    this.state.isPlaying = !this.state.isPlaying;
                    this.updateControls();
                    if (this.state.isPlaying && this.state.stepQueue.length > 0 && !this.state.currentStepPromiseInProgress) {
                        this.state.currentStepPromise = this.executeNextStepChain();
                    }
                },

                handleReset: function() {
                    if (this.state.abortController) {
                        this.state.abortController.abort(); 
                        this.state.abortController = null;
                    }
                    this.state.isReset = true;
                    this.state.isPlaying = false;
                    this.state.stepQueue = [];
                    this.state.currentStepPromise = null;
                    this.state.currentStepPromiseInProgress = false;
                    this.state.tokens = [];
                    this.state.embeddings = [];
                    this.state.contextualizedEmbeddings = [];
                    this.state.generatedTokens = [];
                    this.state.currentStorySequence = [];
                    this.clearVisualizationAreas();
                    this.dom.inputTextArea.disabled = false;
                    this.dom.inputTextArea.value = "tell a story"; 
                    this.dom.eosMessage.style.display = 'none';
                    this.updateStatus("Let's start a new adventure! Type some words.");
                    this.updateControls();
                },

                executeNextStepChain: async function(manualStep = false) {
                    // (This function logic remains largely the same)
                    if (this.state.currentStepPromiseInProgress) return;

                    if (this.state.stepQueue.length === 0) {
                        if (!this.state.isReset) {
                            if (this.state.generatedTokens.find(t => t.text === "EOS")) {
                                this.updateStatus("All done with this adventure! Try 'Again!' or a new sentence.");
                            } else if (this.state.generatedTokens.length > 0) {
                                this.updateStatus("Reached the end of our story blocks for now!");
                            } else {
                                this.updateStatus("Input processing finished.");
                            }
                        }
                        this.state.isPlaying = false;
                        this.updateControls();
                        return;
                    }
                    
                    const stepFunction = this.state.stepQueue.shift();
                    if (stepFunction) {
                        this.state.currentStepPromiseInProgress = true;
                        this.updateControls(); 
                        this.dom.statusPanel.classList.add('active-step');
                        try {
                            await stepFunction.call(this);
                            if (this.state.abortController && this.state.abortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');
                        } catch (error) {
                            this.state.currentStepPromiseInProgress = false;
                            this.dom.statusPanel.classList.remove('active-step');
                            if (error.name === 'AbortError') {
                                console.log("Step aborted");
                                this.updateStatus("Adventure paused or stopped.");
                                this.updateControls();
                                return; 
                            }
                            console.error("Error in simulation step:", stepFunction.name, error);
                            this.updateStatus("Oh no, a glitch! Try 'Again!'");
                            this.updateControls();
                            return;
                        }
                        this.state.currentStepPromiseInProgress = false;
                        this.dom.statusPanel.classList.remove('active-step');

                        if (this.state.isPlaying && !manualStep && this.state.stepQueue.length > 0) {
                            this.state.currentStepPromise = this.sleep(this.getAnimSpeed()).then(() => this.executeNextStepChain());
                        } else if (this.state.stepQueue.length === 0 && !this.state.isReset) {
                             if (this.state.generatedTokens.find(t => t.text === "EOS")) {
                                this.updateStatus("All done with this adventure! Try 'Again!' or a new sentence.");
                            } else if (this.state.generatedTokens.length > 0) {
                                this.updateStatus("Reached the end of our story blocks for now!");
                            } else {
                                this.updateStatus("Input processing finished.");
                            }
                             this.state.isPlaying = false;
                        }
                        this.updateControls();
                    }
                },
                
                tokenizeInput: async function() {
                    this.updateStatus("First, we break your words into 'Word Blocks'!");
                    this.state.tokens = []; 
                    const rawTokens = this.simpleTokenizeText(this.state.userInput);
                    
                    for (let i = 0; i < rawTokens.length; i++) {
                        if (this.state.abortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');
                        const tokenText = rawTokens[i];
                        const tokenId = `token-${i}`;
                        const tokenEl = document.createElement('div');
                        tokenEl.classList.add('token');
                        tokenEl.textContent = tokenText;
                        tokenEl.dataset.tokenId = tokenId;
                        
                        // Token ID not as crucial for a child, but good for debugging
                        // const tokenIdSpan = document.createElement('span');
                        // tokenIdSpan.classList.add('token-id');
                        // tokenIdSpan.textContent = `ID: ${i}`;
                        // tokenEl.appendChild(tokenIdSpan);
                        
                        this.dom.tokensDisplayArea.appendChild(tokenEl);
                        this.state.tokens.push({ id: tokenId, text: tokenText, element: tokenEl, originalIndex: i });
                        tokenEl.classList.add('fade-in');
                        await this.sleep(this.getAnimSpeed(0.4));
                    }
                    if (rawTokens.length === 0 && this.state.userInput.length > 0) { // E.g. if input was just punctuation
                        this.updateStatus("Hmm, couldn't find word blocks. Try words and letters!");
                         this.state.stepQueue = []; // Stop processing
                         return;
                    }
                },

                createEmbeddings: async function() {
                    this.updateStatus("Each Word Block gets its own 'Meaning Colors'!");
                    this.state.embeddings = [];
                    this.state.contextualizedEmbeddings = [];
                    this.dom.embeddingsDisplayArea.innerHTML = '';
                    this.dom.contextualizedEmbeddingsDisplayArea.innerHTML = '';
                    
                    for (const tokenObj of this.state.tokens) {
                        if (this.state.abortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');
                        tokenObj.element.style.opacity = '0.6'; 

                        const vectorColors = this.generateVectorColors(tokenObj.text);
                        
                        const embeddingEl = this.createEmbeddingElement(`emb-${tokenObj.originalIndex}`, vectorColors, tokenObj.text);
                        this.dom.embeddingsDisplayArea.appendChild(embeddingEl);
                        this.state.embeddings.push({ 
                            id: `emb-${tokenObj.originalIndex}`, 
                            vectorColors: [...vectorColors], 
                            posEncoded: false, 
                            element: embeddingEl, 
                            originalTokenText: tokenObj.text,
                            originalIndex: tokenObj.originalIndex // Store index for positional icon
                        });
                        embeddingEl.classList.add('fade-in');

                        const contextualizedEmbeddingEl = this.createEmbeddingElement(`ctx-emb-${tokenObj.originalIndex}`, vectorColors, tokenObj.text);
                        this.dom.contextualizedEmbeddingsDisplayArea.appendChild(contextualizedEmbeddingEl);
                        this.state.contextualizedEmbeddings.push({
                            id: `ctx-emb-${tokenObj.originalIndex}`,
                            vectorColors: [...vectorColors],
                            element: contextualizedEmbeddingEl,
                            originalTokenText: tokenObj.text,
                            originalIndex: tokenObj.originalIndex
                        });
                        contextualizedEmbeddingEl.classList.add('fade-in');
                        
                        await this.sleep(this.getAnimSpeed(0.6));
                    }
                },

                createEmbeddingElement: function(id, colors, labelText) {
                    const el = document.createElement('div');
                    el.classList.add('embedding-bar');
                    el.dataset.embeddingId = id;
                    colors.forEach(color => {
                        const segmentEl = document.createElement('div');
                        segmentEl.classList.add('embedding-segment');
                        segmentEl.style.backgroundColor = color;
                        el.appendChild(segmentEl);
                    });
                    const labelSpan = document.createElement('span');
                    labelSpan.classList.add('vector-label');
                    labelSpan.textContent = labelText;
                    el.appendChild(labelSpan);

                    // NEW: Placeholder for positional icon
                    const posIcon = document.createElement('span');
                    posIcon.classList.add('positional-icon');
                    el.appendChild(posIcon);

                    return el;
                },

                applyPositionalEncoding: async function() {
                    this.updateStatus("Adding 'Order Tags' so we know the word sequence!");
                    for (let i = 0; i < this.state.embeddings.length; i++) {
                        if (this.state.abortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');
                        const embObj = this.state.embeddings[i];
                        embObj.element.classList.add('positional-encoded');
                        embObj.element.querySelector('.positional-icon').textContent = i + 1; // 1-based index for display
                        embObj.posEncoded = true;
                        
                        const ctxEmbObj = this.state.contextualizedEmbeddings[i];
                        ctxEmbObj.element.classList.add('positional-encoded');
                        ctxEmbObj.element.querySelector('.positional-icon').textContent = i + 1;

                        await this.sleep(this.getAnimSpeed(0.3));
                    }
                },
                
                runAttentionMechanism: async function() {
                    this.updateStatus("Word Blocks are 'talking' to understand the sentence!");
                    for (let layer = 0; layer < this.config.attentionLayers; layer++) {
                         if (this.config.attentionLayers > 1) this.updateStatus(`Thinking harder (Round ${layer + 1})...`);
                        
                        const sourceEmbeddingElements = Array.from(this.dom.contextualizedEmbeddingsDisplayArea.children);

                        for (let i = 0; i < sourceEmbeddingElements.length; i++) {
                            if (this.state.abortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');
                            
                            const currentQueryElement = sourceEmbeddingElements[i];
                            currentQueryElement.classList.add('is-processing');
                            const currentTokenText = this.state.contextualizedEmbeddings[i].originalTokenText;
                            this.updateStatus(`The block "${currentTokenText}" is 'listening' to others...`);

                            const attentionLines = [];
                            for (let j = 0; j < sourceEmbeddingElements.length; j++) {
                                const currentKeyElement = sourceEmbeddingElements[j];
                                let weight = (i === j) ? 0.9 : Math.max(0.1, 1 - Math.abs(i - j) * 0.2 + Math.random() * 0.4);
                                weight = Math.min(1, Math.max(0, weight));

                                const line = this.drawAttentionLine(currentQueryElement, currentKeyElement, weight);
                                if(line) {
                                    this.dom.transformerLayerArea.appendChild(line);
                                    attentionLines.push(line);
                                }
                            }
                            
                            await this.sleep(this.getAnimSpeed(1.2));
                            
                            // Enhanced "update" of contextualized embedding
                            const originalColors = this.state.contextualizedEmbeddings[i].vectorColors;
                            const newColors = originalColors.map(hex => { // Shift colors slightly
                                let r = parseInt(hex.slice(1,3), 16);
                                let g = parseInt(hex.slice(3,5), 16);
                                let b = parseInt(hex.slice(5,7), 16);
                                r = Math.min(255, Math.max(0, r + (Math.random() > 0.5 ? 20 : -20)));
                                g = Math.min(255, Math.max(0, g + (Math.random() > 0.5 ? 20 : -20)));
                                b = Math.min(255, Math.max(0, b + (Math.random() > 0.5 ? 20 : -20)));
                                return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
                            });

                            this.state.contextualizedEmbeddings[i].vectorColors = newColors; // Store the new colors
                            const segments = this.state.contextualizedEmbeddings[i].element.querySelectorAll('.embedding-segment');
                            segments.forEach((seg, segIdx) => seg.style.backgroundColor = newColors[segIdx % newColors.length]);
                            this.state.contextualizedEmbeddings[i].element.classList.add('contextualized');
                            
                            attentionLines.forEach(line => line.remove());
                            currentQueryElement.classList.remove('is-processing');
                            await this.sleep(this.getAnimSpeed(0.6));
                        }
                    }
                    this.updateStatus("All Word Blocks now understand each other better!");
                },
                
                prepareForGeneration: async function() {
                    this.updateStatus("Getting ready to build the computer's answer!");
                    this.state.generatedTokens = [];
                    this.dom.outputAssemblyArea.innerHTML = '';
                    this.dom.eosMessage.style.display = 'none';
                    this.state.stepQueue.unshift(this.predictAndGenerateToken); 
                },

                predictAndGenerateToken: async function() {
                    if (this.state.abortController.signal.aborted) throw new DOMException('Aborted', 'AbortError');
                    if (this.state.generatedTokens.length >= this.config.maxGeneratedTokens) {
                        this.updateStatus(`That's a lot of blocks! We'll stop here.`);
                        this.displayFinalOutput();
                        return; 
                    }

                    this.updateStatus("Guessing the next Word Block for the answer...");
                    this.dom.probabilityDisplayArea.innerHTML = '';
                    
                    // NEW: Use predefined story sequence for next token
                    let selectedTokenText;
                    if (this.state.currentStorySequence.length > 0) {
                        selectedTokenText = this.state.currentStorySequence.shift(); // Get next word from our story
                    } else {
                        selectedTokenText = "EOS"; // Story finished
                    }

                    // Show some "fake" probabilities for visualization
                    const probabilities = this.config.vocab
                        .filter(v => v !== "EOS" || selectedTokenText === "EOS") // Don't suggest EOS too early if not the pre-defined one
                        .map(vocabToken => ({
                            token: vocabToken,
                            // Make the pre-selected token have high probability
                            prob: (vocabToken === selectedTokenText) ? (0.8 + Math.random() * 0.2) : (Math.random() * 0.5)
                        }))
                        .sort((a,b) => b.prob - a.prob)
                        .slice(0, this.config.topNProbabilities);
                    
                    // Ensure the selected token is in the top N for display
                    if (!probabilities.find(p => p.token === selectedTokenText) && selectedTokenText) {
                        probabilities.pop(); // remove the last one
                        probabilities.push({token: selectedTokenText, prob: 0.75 + Math.random() * 0.1}); // Add it
                        probabilities.sort((a,b) => b.prob - a.prob); // re-sort
                    }


                    for(let i=0; i < probabilities.length; i++) {
                        const bar = document.createElement('div');
                        bar.classList.add('prob-bar');
                        const barHeight = probabilities[i].prob * 75 + 15; // Min height 15px, max 90px
                        bar.style.height = `${barHeight}px`;
                        
                        const barLabel = document.createElement('span');
                        barLabel.textContent = probabilities[i].token;
                        bar.appendChild(barLabel);
                        bar.dataset.token = probabilities[i].token;
                        if (probabilities[i].token === selectedTokenText) {
                            bar.classList.add('selected');
                        }
                        this.dom.probabilityDisplayArea.appendChild(bar);
                    }
                    await this.sleep(this.getAnimSpeed(1.2));


                    this.updateStatus(`The computer picks: "${selectedTokenText}"!`);
                    await this.sleep(this.getAnimSpeed(0.8));

                    this.updateStatus("Adding it to the answer sentence...");
                    const outputTokenEl = document.createElement('div');
                    outputTokenEl.classList.add('output-token', 'fade-in');
                    outputTokenEl.textContent = selectedTokenText;
                    if (selectedTokenText === "EOS") {
                        outputTokenEl.classList.add('eos');
                        this.dom.eosMessage.style.display = 'block';
                    }
                    this.dom.outputAssemblyArea.appendChild(outputTokenEl);
                    const currentTokenObj = { text: selectedTokenText, element: outputTokenEl };
                    this.state.generatedTokens.push(currentTokenObj);
                    await this.sleep(this.getAnimSpeed(0.6));

                    if (selectedTokenText !== "EOS") {
                        this.updateStatus("Remembering this new block for the *next* guess...");
                        const feedbackEl = currentTokenObj.element.cloneNode(true);
                        feedbackEl.classList.add('feedback-animation-token');
                        const outputRect = this.dom.outputAssemblyArea.getBoundingClientRect();
                        // Target the contextualized embeddings as that's the "thinking space"
                        const contextRect = this.dom.contextualizedEmbeddingsDisplayArea.getBoundingClientRect(); 
                        
                        const startX = currentTokenObj.element.offsetLeft + currentTokenObj.element.offsetWidth / 2;
                        const startY = currentTokenObj.element.offsetTop + currentTokenObj.element.offsetHeight / 2;
                        feedbackEl.style.left = `${startX - feedbackEl.offsetWidth / 2}px`;
                        feedbackEl.style.top = `${startY - feedbackEl.offsetHeight / 2}px`;
                        this.dom.outputAssemblyArea.appendChild(feedbackEl);

                        const endX = (contextRect.left + contextRect.width / 2) - (outputRect.left + feedbackEl.offsetWidth / 2) ;
                        const endY = (contextRect.top + contextRect.height / 2) - (outputRect.top + feedbackEl.offsetHeight / 2);
                        
                        void feedbackEl.offsetWidth; 

                        feedbackEl.style.transform = `translate(${endX}px, ${endY}px) scale(0.5)`;
                        feedbackEl.style.opacity = '0';
                        
                        await this.sleep(this.getAnimSpeed(1.8)); 
                        feedbackEl.remove();

                        this.state.stepQueue.unshift(this.predictAndGenerateToken);
                    } else {
                        this.updateStatus("The computer added a 'Stop' block. All done!");
                        this.displayFinalOutput();
                    }
                },
                
                updateStatus: function(message) {
                    this.dom.statusPanel.textContent = message;
                },
                updateControls: function() {
                    // (Control update logic is the same)
                    const P = this.state.currentStepPromiseInProgress;
                    const Q = this.state.stepQueue.length === 0;
                    const R = this.state.isReset;

                    this.dom.processBtn.disabled = this.state.isPlaying || P || !R;
                    this.dom.nextStepBtn.disabled = this.state.isPlaying || P || Q || R;
                    this.dom.playPauseBtn.disabled = R || (Q && !P);
                    this.dom.playPauseBtn.textContent = this.state.isPlaying ? "Pause" : "Play All";
                    this.dom.resetBtn.disabled = R && !P; 
                    this.dom.inputTextArea.disabled = !R;
                },
                clearVisualizationAreas: function() {
                    // (Clearing logic is the same)
                    this.dom.tokensDisplayArea.innerHTML = '';
                    this.dom.embeddingsDisplayArea.innerHTML = '';
                    this.dom.contextualizedEmbeddingsDisplayArea.innerHTML = '';
                    this.dom.probabilityDisplayArea.innerHTML = '';
                    this.dom.outputAssemblyArea.innerHTML = '';
                    this.dom.eosMessage.style.display = 'none';
                    const attentionLines = this.dom.transformerLayerArea.querySelectorAll('.attention-line');
                    attentionLines.forEach(line => line.remove());
                },
                displayVocabulary: function() {
                    this.dom.vocabularyDisplayArea.innerHTML = 'Computer knows these Word Blocks: ';
                    // Show a subset for brevity in UI
                    const vocabToShow = [...this.config.vocab].sort(() => 0.5 - Math.random()).slice(0, 15);
                    if (!vocabToShow.includes("EOS")) vocabToShow.push("EOS");

                    vocabToShow.forEach(vtoken => {
                        const el = document.createElement('span');
                        el.classList.add('vocab-token');
                        el.textContent = vtoken;
                        this.dom.vocabularyDisplayArea.appendChild(el);
                    });
                },
                simpleTokenizeText: function(text) {
                    if (!text) return [];
                    // Simple split by space, and remove punctuation for this simplified version
                    return text.trim().toLowerCase()
                        .replace(/[.,!?;:"']/g, '') // Remove common punctuation
                        .split(/\s+/)
                        .filter(t => t.length > 0);
                },
                generateVectorColors: function(textSeed) {
                    // (Color generation can remain similar, maybe ensure more vibrancy)
                    let hash = 0;
                    for (let i = 0; i < textSeed.length; i++) {
                        hash = textSeed.charCodeAt(i) + ((hash << 5) - hash);
                        hash = hash & hash; 
                    }
                    const colors = [];
                    const colorBases = [ // Brighter base colors
                        [255, 100, 100], [100, 255, 100], [100, 100, 255], 
                        [255, 255, 100], [255, 100, 255], [100, 255, 255]
                    ];
                    for (let i = 0; i < this.config.embeddingSize; i++) {
                        const baseIdx = Math.abs(hash + i*3) % colorBases.length;
                        const r = (colorBases[baseIdx][0] + (hash & (0x3F << (i*2 % 12))) - 31) % 200 + 55;
                        const g = (colorBases[baseIdx][1] + (hash & (0x3F << (i*3 % 12))) - 31) % 200 + 55;
                        const b = (colorBases[baseIdx][2] + (hash & (0x3F << (i*4 % 12))) - 31) % 200 + 55;
                        colors.push(`rgb(${Math.max(0,Math.min(255,r))}, ${Math.max(0,Math.min(255,g))}, ${Math.max(0,Math.min(255,b))})`);
                    }
                    return colors;
                },
                drawAttentionLine: function(sourceEl, targetEl, weight) {
                    // (Drawing attention lines remains similar, styling handled in CSS)
                    const parentRect = this.dom.transformerLayerArea.getBoundingClientRect();
                    const sourceRect = sourceEl.getBoundingClientRect();
                    const targetRect = targetEl.getBoundingClientRect();

                    if (!sourceRect.width || !targetRect.width) return null;

                    const line = document.createElement('div');
                    line.classList.add('attention-line');
                    
                    const x1 = sourceRect.left + sourceRect.width / 2 - parentRect.left;
                    const y1 = sourceRect.top + sourceRect.height / 2 - parentRect.top;
                    const x2 = targetRect.left + targetRect.width / 2 - parentRect.left;
                    const y2 = targetRect.top + targetRect.height / 2 - parentRect.top;

                    const length = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
                    const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

                    line.style.width = `${length}px`;
                    line.style.left = `${x1}px`;
                    line.style.top = `${y1}px`;
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.opacity = `${Math.max(0.2, weight * 0.9 + 0.1)}`; // Make lines more visible
                    line.style.height = `${Math.max(2, weight * 5)}px`; 
                    if (weight > 0.8) line.style.backgroundColor = 'rgba(231, 76, 60, 0.8)'; // Stronger attention more red
                    else if (weight > 0.5) line.style.backgroundColor = 'rgba(243, 156, 18, 0.8)';
                    
                    return line;
                },
                displayFinalOutput: function() {
                    const finalText = this.state.generatedTokens
                        .filter(t => t.text !== "EOS")
                        .map(t => t.text)
                        .join(" ");
                    this.updateStatus(`The computer's full answer is: "${finalText}" Great job!`);
                },
            };

            document.addEventListener('DOMContentLoaded', () => {
                LLMSim.init();
            });
        })();
    </script>
</body>
</html>
